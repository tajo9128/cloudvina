# BioDockify: Complete 6‑Step Vina + GNINA + Random Forest Architecture

**Project:** BioDockify / CloudVina  
**Goal:** International‑level, publication‑grade molecular docking SaaS

---

## Overview

This document specifies the **end‑to‑end backend architecture** for combining:

1. **AutoDock Vina** – fast physics‑based docking
2. **GNINA** – deep‑learning CNN scoring
3. **Random Forest (RF)** – ML‑based consensus rescoring

All three are orchestrated in a **6‑step pipeline** suitable for a Dockerized Django/Celery backend.

High‑level flow:

```text
User → Web UI → Django API → Celery Queue →
    [Prep] → [Vina] → [GNINA] → [Features] → [RF] → [Results]
```

---

## STEP 1 – Input Validation & Preparation

**Purpose:** Ensure only chemically and structurally valid inputs reach the docking engines.

### 1.1 Inputs

- Protein structure: `protein.pdb` (uploaded or fetched by PDB ID)
- Ligand representation: SMILES / SDF / MOL2
- Optional: Known binding site residues or reference ligand

### 1.2 Operations

1. **Ligand preparation**
   - Convert SMILES → 3D SDF
   - Add hydrogens and generate a low‑energy 3D conformation
   - Convert SDF → PDBQT for Vina/GNINA

2. **Receptor preparation**
   - Clean PDB (remove water, ions unless needed)
   - Add hydrogens (especially polar)
   - Assign charges and atom types
   - Convert PDB → PDBQT

3. **Binding site / grid box detection**
   - Preferred: detect co‑crystallized ligand (`HETATM` non‑HOH) and compute its centroid
   - Alternative: use user‑supplied pocket residues and compute centroid of CA atoms
   - Fallback: run pocket detector (e.g., fpocket/p2rank) and pick top pocket

4. **Grid box setup**
   - Center = detected pocket center (never default to 0,0,0)
   - Size (Å):
     - Default: `22 × 22 × 22`
     - Adjust upwards for large ligands (ligand max diameter + 8 Å)

### 1.3 Outputs

- `receptor.pdbqt` – prepared receptor
- `ligand.pdbqt` – prepared ligand
- Grid box parameters: `center_x/y/z`, `size_x/y/z`
- Vina configuration file: `vina_config.txt`

---

## STEP 2 – AutoDock Vina Docking

**Purpose:** Generate plausible poses quickly and obtain baseline physics‑based scores.

### 2.1 Inputs

- `receptor.pdbqt`
- `ligand.pdbqt`
- `vina_config.txt`

### 2.2 Operations

1. Run Vina:

   ```bash
   vina --config vina_config.txt --out vina_output.pdbqt --log vina.log
   ```

2. Parameters (recommended defaults):
   - `exhaustiveness = 16` (accuracy–time balance)
   - `num_modes = 9`
   - CPU usage: all available cores inside container

3. Parse output:
   - Extract energies and RMSD from `REMARK VINA RESULT` lines
   - Split multi‑model PDBQT into per‑pose files (`pose_1.pdbqt`, `pose_2.pdbqt`, ...)

### 2.3 Outputs

- `vina_output.pdbqt` – all poses
- Per‑pose PDBQT files – `pose_i.pdbqt`
- Pose‑level metadata (affinity, RMSD)

---

## STEP 3 – GNINA Deep‑Learning Rescoring

**Purpose:** Apply CNN‑based scoring to reevaluate the poses generated by Vina.

### 3.1 Inputs

- `receptor.pdbqt`
- `vina_output.pdbqt` (all poses)
- Optional: `crystal_ligand.sdf` (for `--autobox_ligand`)

### 3.2 Operations

1. Run GNINA:

   ```bash
   gnina \
     -r receptor.pdbqt \
     -l vina_output.pdbqt \
     --out gnina_output.sdf \
     --num_modes 9
   ```

2. If a reference ligand is available:

   ```bash
   gnina \
     -r receptor.pdbqt \
     -l vina_output.pdbqt \
     --autobox_ligand crystal_ligand.sdf \
     --autobox_add 4 \
     --out gnina_output.sdf \
     --num_modes 9
   ```

3. Parse GNINA SDF tags:
   - `CNNscore` – confidence that pose is realistic
   - `CNNaffinity` – predicted pKd/affinity

### 3.3 Outputs

- `gnina_output.sdf` – poses with CNN annotations
- Per‑pose CNN metadata:
  - `cnn_score`
  - `cnn_affinity`

---

## STEP 4 – Feature Extraction (ODDT‑Based)

**Purpose:** Convert 3D protein–ligand complexes into numerical feature vectors for RF.

### 4.1 Inputs

- Individual pose files: `pose_i.pdbqt`
- `receptor.pdbqt`
- Pose‑level Vina and GNINA scores

### 4.2 Operations

1. Load receptor and pose using ODDT
2. Compute **Interaction Fingerprint** (IFP), e.g.:
   - Hydrogen bonds (backbone / side chain)
   - Hydrophobic contacts
   - π–π stacking
   - Salt bridges
   - Metal interactions
3. Build feature vector per pose:

   Example composition (≈ 50–60 features):
   - 5 Vina components (or proxies if detailed terms are not available)
   - 2 GNINA scores: `cnn_score`, `cnn_affinity`
   - ~40–50 IFP features (bit vector or counts)

### 4.3 Outputs

- Feature matrix `X` (N poses × D features)
- Associated metadata (pose IDs, structures)

---

## STEP 5 – Random Forest Consensus Scoring

**Purpose:** Use a trained Random Forest model to predict binding affinity (pKd) per pose and form a consensus score.

### 5.1 Inputs

- Feature vector for each pose
- Trained RF model, e.g. `rf_model_v2.1.pkl`

### 5.2 Operations

1. **Prediction**
   - Pass feature vectors to RF model → obtain predicted pKd values

2. **Consensus scoring**
   - Normalize inputs:
     - Vina affinity (−12 to 0 kcal/mol) → 0–10
     - GNINA CNNscore (0–1) → 0–10
     - RF pKd (0–10) stays as is
   - Compute weighted consensus (example weights):

     ```text
     consensus = 0.30 * Vina_norm + 0.40 * GNINA_norm + 0.30 * RF_norm
     ```

3. Optional: SHAP explainability
   - Use SHAP to compute feature importance per pose
   - Expose top contributors (e.g., H‑bonds, CNNscore, hydrophobic contacts)

### 5.3 Outputs

For each pose:

- `vina_affinity`
- `gnina_cnn_score`, `gnina_cnn_affinity`
- `rf_predicted_pKd`
- `consensus_score`
- Optional: SHAP‑based explanation

---

## STEP 6 – Results Aggregation & API Response

**Purpose:** Package all computed data into a reproducible, user‑friendly result for the BioDockify frontend.

### 6.1 Inputs

- Per‑pose results from steps 2–5
- Job metadata (job ID, timestamps, versions, grid box, etc.)

### 6.2 Operations

1. **Ranking**
   - Sort poses by `consensus_score` (desc)
   - Mark top N (e.g., top 3) as primary candidates

2. **Result structure**
   - Build JSON object for API response:

     ```json
     {
       "job_id": "uuid-here",
       "timestamp": "2025-12-26T14:00:00Z",
       "versions": {
         "vina": "1.2.5",
         "gnina": "1.0.3",
         "rf_model": "v2.1-pdbbind-refined"
       },
       "grid_box": {
         "center": [15.43, 38.90, 22.15],
         "size": [22, 22, 22]
       },
       "poses": [
         {
           "pose_id": 1,
           "vina_affinity": -8.4,
           "vina_rmsd_ub": 0.0,
           "gnina_cnn_score": 0.82,
           "gnina_cnn_affinity": 7.2,
           "rf_predicted_pKd": 7.0,
           "consensus_score": 8.1
         },
         {
           "pose_id": 2,
           "vina_affinity": -7.9,
           "gnina_cnn_score": 0.78,
           "rf_predicted_pKd": 6.8,
           "consensus_score": 7.6
         }
       ]
     }
     ```

3. **Reproducibility metadata**
   - Include:
     - `receptor_md5`, `ligand_md5`
     - Docker image tags
     - RF model hash

4. **Expose via Django REST API**
   - `/api/docking/jobs/{job_id}/` → job status + results
   - `/api/docking/jobs/{job_id}/download/` → ZIP: PDBQT + JSON + CSV + methods text

### 6.3 Outputs

- JSON response for frontend
- Downloadable artifacts (PDBQT, SDF, JSON, CSV, Methods.md)

---

## Optional: Queue & Scaling Layer (Celery + Redis + Kubernetes)

To support many users and heavy workloads:

- Use **Celery** to run each 6‑step pipeline as an asynchronous task
- Use **Redis** as the broker and result backend
- Deploy workers in **Kubernetes** clusters with autoscaling
- Separate worker types:
  - `prep-worker` – ligand/protein prep
  - `vina-worker` – CPU‑heavy docking
  - `gnina-worker` – GPU‑enabled pods
  - `ml-worker` – RF + SHAP

---

## How to Use This Architecture in BioDockify

1. Implement each step as an isolated Python module in your Django backend (`backend/docking/`, `backend/ml_models/`).
2. Wire them together in a `DockingPipeline` class that executes the 6 steps in sequence.
3. Wrap the pipeline in a Celery task so jobs are queued and run asynchronously.
4. Expose simple APIs for the frontend:
   - `POST /api/docking/submit` – submit PDB + SMILES
   - `GET /api/docking/{job_id}` – get status/results
5. Add monitoring to track runtime, errors, and nightly validation runs.

This 6‑step architecture is suitable for **Scopus‑indexed publications**, **international collaborations**, and future commercial SaaS scaling.
